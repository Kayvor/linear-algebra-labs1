import pygame
import numpy as np

# --- Конфигурация ---
ШИРИНА_ЭКРАНА, ВЫСОТА_ЭКРАНА = 800, 600 # Размеры окна для отображения
ЦВЕТ_ФОНА = (30, 30, 30)                # Цвет фона сцены (темно-серый)
БАЗОВЫЙ_ЦВЕТ_СПИРАЛИ = (100, 150, 250)    # Базовый цвет для спиральной поверхности
БАЗОВЫЙ_ЦВЕТ_УЗЛА = (250, 100, 120)      # Базовый цвет для тороидального узла

# --- Параметры индикатора осей координат (2D X/Y + 3D Z в углу) ---
ЦВЕТ_ИНД_ОСИ_X = (255, 50, 50) # Красный цвет для оси X индикатора
ЦВЕТ_ИНД_ОСИ_Y = (50, 255, 50) # Зеленый цвет для оси Y индикатора
ЦВЕТ_ИНД_ОСИ_Z = (50, 50, 255) # Синий цвет для оси Z индикатора
ДЛИНА_ИНД_ОСЕЙ_2D = 40      # Длина 2D-осей X и Y на экране в пикселях
ДЛИНА_ИНД_ОСИ_Z_3D = 1.0    # "Реальная" длина 3D-отрезка оси Z индикатора (в мировых координатах)
ТОЛЩИНА_ЛИНИИ_ИНД_ОСЕЙ = 3 # Толщина линий для индикатора осей
ОТСТУП_ИНД_ОСЕЙ_X = 50      # Отступ индикатора от левого края экрана
ОТСТУП_ИНД_ОСЕЙ_Y = 50      # Отступ индикатора от нижнего края экрана
МАСШТАБ_ДЛЯ_ПРОЕКЦИИ_Z_ИНД = 30 # Масштаб, применяемый при проекции 3D-отрезка оси Z индикатора

# --- Параметры сетки на "полу" ---
ЦВЕТ_СЕТКИ = (80, 80, 80) # Цвет линий сетки
РАЗМЕР_СЕТКИ = 10         # Количество линий сетки в каждом направлении от центра
ШАГ_СЕТКИ = 1.0           # Расстояние между линиями сетки в мировых координатах
Y_ПЛОСКОСТИ_СЕТКИ = -2.5  # Высота (координата Y), на которой будет нарисована сетка

# --- Параметры фигур ---
# Спиральная поверхность
ALPHA_SPIRAL = 2.0
BETA_SPIRAL = 0.5
U_MIN_SPIRAL, U_MAX_SPIRAL = 0, 4*np.pi # Диапазон параметра U
V_MIN_SPIRAL, V_MAX_SPIRAL = 0, 2*np.pi # Диапазон параметра V
КОЛ_ВО_ШАГОВ_U_СПИРАЛЬ = 70 # Количество шагов (детализация) по параметру U
КОЛ_ВО_ШАГОВ_V_СПИРАЛЬ = 35 # Количество шагов (детализация) по параметру V

# Тороидальный узел (Torus Knot)
P_KNOT, Q_KNOT = 2,3 # Параметры формы узла (p,q - целые, обычно взаимно простые)
RADIUS_MAJOR_KNOT = 2.0  # Большой радиус "основы" тора
RADIUS_MINOR_KNOT = 0.5  # Малый радиус "трубки" узла
U_MIN_KNOT, U_MAX_KNOT = 0, 2*np.pi # Диапазон параметра U (основная кривая узла)
V_MIN_KNOT, V_MAX_KNOT = 0, 2*np.pi # Диапазон параметра V (сечение "трубки")
КОЛ_ВО_ШАГОВ_U_КНОТ = 120
КОЛ_ВО_ШАГОВ_V_КНОТ = 20  

# --- Параметры освещения ---
НАПРАВЛЕНИЕ_СВЕТА_МИР = np.array([0.6,0.8,-1.0]) # Вектор направления источника света в мировых координатах
НАПРАВЛЕНИЕ_СВЕТА_МИР = НАПРАВЛЕНИЕ_СВЕТА_МИР / np.linalg.norm(НАПРАВЛЕНИЕ_СВЕТА_МИР) # Нормализация вектора
ОКРУЖАЮЩИЙ_СВЕТ = 0.25      # Интенсивность окружающего (фонового, ambient) света (0.0-1.0)
ЯРКОСТЬ_ДИФФУЗНОГО = 0.75 # Коэффициент диффузного отражения (0.0-1.0)

# --- Глобальные переменные для состояния сцены и камеры ---
угол_пов_x_град = 20.0 # Текущий угол поворота объекта/сцены вокруг оси X (в градусах)
угол_пов_y_град = 30.0 # Текущий угол поворота объекта/сцены вокруг оси Y (в градусах)
угол_пов_z_град = 0.0  # Текущий угол поворота объекта/сцены вокруг оси Z (в градусах)
масштабный_коэфф = 50.0 # Текущий масштабный коэффициент для проекции (приближение/отдаление)

# --- Идентификаторы типов фигур ---
ТИП_ФИГУРЫ_СПИРАЛЬ = "spiral"
ТИП_ФИГУРЫ_УЗЕЛ = "torus_knot"
текущая_фигура = ТИП_ФИГУРЫ_СПИРАЛЬ # Фигура, отображаемая по умолчанию при запуске
базовый_цвет_текущей_фигуры = БАЗОВЫЙ_ЦВЕТ_СПИРАЛИ # Цвет для текущей фигуры

# --- Хранилища для геометрии (вычисляются один раз при смене фигуры) ---
точки_поверхности_3d_оригинал = np.array([]) # Массив 3D-координат вершин текущей фигуры
нормали_квадов_оригинал = np.array([])       # Массив нормалей к квадам (полигонам) текущей фигуры
текущие_шаги_u = 0 # Актуальное количество шагов по U для текущей фигуры
текущие_шаги_v = 0 # Актуальное количество шагов по V для текущей фигуры

# --- Параметрические функции для генерации точек фигур ---
# Каждая такая функция принимает параметры u, v и специфичные для фигуры параметры,
# и возвращает 3D-координаты (x,y,z) точки на поверхности.
def точка_спиральной_поверхности(u,v,alpha,beta): 
    x=(alpha+beta*np.cos(v))*np.cos(u)
    y=(alpha+beta*np.cos(v))*np.sin(u)
    z_val=beta*np.sin(v)+alpha*u
    return np.array([x,y,z_val])

def точка_тороидального_узла(u,v,p,q,R_major,r_minor): 
    # Упрощенная параметризация для визуализации "утолщенного" узла.
    # Строится "волнистая" центральная линия, а затем вокруг нее "трубка".
    x_center=(R_major)*np.cos(p*u)
    y_center=(R_major)*np.sin(p*u)
    z_waving=R_major*0.3*np.sin(q*u)
    # Вычисление локальной системы координат (касательная, нормаль1, нормаль2) для ориентации трубки
    dx_center=-p*R_major*np.sin(p*u); dy_center=p*R_major*np.cos(p*u); dz_waving=q*R_major*0.3*np.cos(q*u)
    tangent=np.array([dx_center,dy_center,dz_waving]); norm_t=np.linalg.norm(tangent)
    tangent=np.array([1,0,0]) if norm_t<1e-6 else tangent/norm_t
    up_vector=np.array([0,0,1.0]); up_vector=np.array([0,1.0,0]) if np.abs(np.dot(tangent,up_vector))>0.99 else up_vector
    normal1=np.cross(tangent,up_vector); norm_n1=np.linalg.norm(normal1)
    normal1=np.array([np.cos(p*u+np.pi/2),np.sin(p*u+np.pi/2),0]) if norm_n1<1e-6 else normal1/norm_n1
    normal2=np.cross(tangent,normal1); norm_n2=np.linalg.norm(normal2)
    normal2=np.array([0,0,1]) if norm_n2<1e-6 else normal2/norm_n2 # Запасной вариант для normal2
    # Генерация точки на поверхности трубки
    px=x_center+r_minor*(normal1[0]*np.cos(v)+normal2[0]*np.sin(v))
    py=y_center+r_minor*(normal1[1]*np.cos(v)+normal2[1]*np.sin(v))
    pz=z_waving+r_minor*(normal1[2]*np.cos(v)+normal2[2]*np.sin(v))
    return np.array([px,py,pz])

# --- Функции 3D преобразований (поворот точек) ---
# Поворот точки последовательно вокруг осей X, Y, Z.
def повернуть_точку(точка_3d, угол_x_рад, угол_y_рад, угол_z_рад): 
    p=повернуть_по_x(точка_3d,угол_x_рад)
    p=повернуть_по_y(p,угол_y_рад)
    p=повернуть_по_z(p,угол_z_рад)
    return p

def повернуть_по_x(точка, угол_рад): 
    c,s=np.cos(угол_рад),np.sin(угол_рад)
    x,y,z=точка
    return np.array([x,y*c-z*s,y*s+z*c])

def повернуть_по_y(точка, угол_рад): 
    c,s=np.cos(угол_рад),np.sin(угол_рад)
    x,y,z=точка
    return np.array([x*c+z*s,y,-x*s+z*c])

def повернуть_по_z(точка, угол_рад): 
    c,s=np.cos(угол_рад),np.sin(угол_рад)
    x,y,z=точка
    return np.array([x*c-y*s,x*s+y*c,z])

# --- Проекция 3D точки на 2D экран и растеризация треугольника ---
# Ортографическая проекция с масштабированием и сдвигом в центр экрана.
def спроецировать_точку(точка_повернутая, масштаб, центр_x, центр_y): 
    x,y,z_глубина=точка_повернутая # z_глубина используется для Z-буфера
    экран_x=центр_x+x*масштаб
    экран_y=центр_y-y*масштаб # Ось Y экрана направлена вниз, поэтому инверсия
    return int(экран_x),int(экран_y),z_глубина

# Растеризация (заливка) треугольника с использованием барицентрических координат и Z-буфера.
def нарисовать_треугольник(массив_пикселей_экрана, z_буфер, v0_proj, v1_proj, v2_proj, цвет):
    (x0,y0,z0)=v0_proj;(x1,y1,z1)=v1_proj;(x2,y2,z2)=v2_proj # Координаты вершин треугольника на экране

    # Определение ограничивающего прямоугольника треугольника для оптимизации перебора пикселей
    min_x=max(0,min(x0,x1,x2));max_x=min(ШИРИНА_ЭКРАНА-1,max(x0,x1,x2))
    min_y=max(0,min(y0,y1,y2));max_y=min(ВЫСОТА_ЭКРАНА-1,max(y0,y1,y2))

    # Знаменатель для вычисления барицентрических координат (удвоенная знаковая площадь треугольника)
    знаменатель=(y1-y2)*(x0-x2)+(x2-x1)*(y0-y2)
    if abs(знаменатель)<1e-9:return # Если знаменатель близок к нулю, треугольник вырожденный (линия или точка)

    # Перебор пикселей в ограничивающем прямоугольнике
    for px in range(min_x,max_x+1):
        for py in range(min_y,max_y+1):
            # Вычисление барицентрических координат (w0, w1, w2) для текущего пикселя (px, py)
            w0=((y1-y2)*(px-x2)+(x2-x1)*(py-y2))/знаменатель
            w1=((y2-y0)*(px-x0)+(x0-x2)*(py-y0))/знаменатель
            w2=1.0-w0-w1

            # Если пиксель внутри треугольника (все веса >= 0 с небольшой погрешностью)
            if w0>=-1e-4 and w1>=-1e-4 and w2>=-1e-4:
                # Интерполяция глубины (Z-координаты) для текущего пикселя
                глубина_пикселя=w0*z0+w1*z1+w2*z2
                
                # Z-тест: если текущий пиксель ближе, чем уже нарисованный в этой точке
                if глубина_пикселя < z_буфер[py,px]: # Меньшая глубина = ближе к камере
                    z_буфер[py,px]=глубина_пикселя # Обновляем Z-буфер
                    массив_пикселей_экрана[py,px]=цвет # Рисуем пиксель

# --- Предварительное вычисление геометрии фигуры ---
# Вызывается при запуске и при смене фигуры (клавиша TAB).
# Генерирует массив вершин и нормалей для выбранной фигуры.
def вычислить_исходную_геометрию(тип_фигуры_для_генерации):
    global точки_поверхности_3d_оригинал,нормали_квадов_оригинал,текущие_шаги_u,текущие_шаги_v,базовый_цвет_текущей_фигуры
    args_fn=None; fn_гт=None # fn_гт = функция_генерации_точек
    
    # Выбор параметров и функции генерации в зависимости от типа фигуры
    if тип_фигуры_для_генерации==ТИП_ФИГУРЫ_СПИРАЛЬ: 
        текущие_шаги_u=КОЛ_ВО_ШАГОВ_U_СПИРАЛЬ; текущие_шаги_v=КОЛ_ВО_ШАГОВ_V_СПИРАЛЬ
        значения_u=np.linspace(U_MIN_SPIRAL,U_MAX_SPIRAL,текущие_шаги_u); значения_v=np.linspace(V_MIN_SPIRAL,V_MAX_SPIRAL,текущие_шаги_v)
        базовый_цвет_текущей_фигуры=БАЗОВЫЙ_ЦВЕТ_СПИРАЛИ; fn_гт=точка_спиральной_поверхности; args_fn=(ALPHA_SPIRAL,BETA_SPIRAL)
        print("Геометрия СПИРАЛИ сгенерирована.")
    elif тип_фигуры_для_генерации==ТИП_ФИГУРЫ_УЗЕЛ: 
        текущие_шаги_u=КОЛ_ВО_ШАГОВ_U_КНОТ; текущие_шаги_v=КОЛ_ВО_ШАГОВ_V_КНОТ
        значения_u=np.linspace(U_MIN_KNOT,U_MAX_KNOT,текущие_шаги_u); значения_v=np.linspace(V_MIN_KNOT,V_MAX_KNOT,текущие_шаги_v)
        базовый_цвет_текущей_фигуры=БАЗОВЫЙ_ЦВЕТ_УЗЛА; fn_гт=точка_тороидального_узла; args_fn=(P_KNOT,Q_KNOT,RADIUS_MAJOR_KNOT,RADIUS_MINOR_KNOT)
        print("Геометрия УЗЛА сгенерирована.")
    else: print(f"Ошибка: неизвестный тип фигуры '{тип_фигуры_для_генерации}'"); return
    
    # Генерация 3D-координат вершин
    точки_поверхности_3d_оригинал=np.zeros((текущие_шаги_u,текущие_шаги_v,3))
    for i_u,u_val in enumerate(значения_u):
        for i_v,v_val in enumerate(значения_v): точки_поверхности_3d_оригинал[i_u,i_v]=fn_гт(u_val,v_val,*args_fn)
            
    # Вычисление нормалей к поверхности (для каждого квада)
    # Нормаль используется для расчета освещения и отсечения невидимых граней.
    нормали_квадов_оригинал=np.zeros((текущие_шаги_u-1,текущие_шаги_v-1,3))
    for i_u in range(текущие_шаги_u-1):
        for i_v in range(текущие_шаги_v-1): 
            п00=точки_поверхности_3d_оригинал[i_u,i_v]; п10=точки_поверхности_3d_оригинал[i_u+1,i_v]; п01=точки_поверхности_3d_оригинал[i_u,i_v+1]
            вектор_a=п10-п00; вектор_b=п01-п00 # Векторы, образующие плоскость квада
            нормаль=np.cross(вектор_a,вектор_b)  # Векторное произведение дает нормаль
            длина_нормали=np.linalg.norm(нормаль)
            if длина_нормали > 1e-9: нормали_квадов_оригинал[i_u,i_v]=нормаль/длина_нормали # Нормализация вектора нормали
            else: нормали_квадов_оригинал[i_u,i_v]=np.array([0,0,1]) # Нормаль по умолчанию для вырожденных случаев

# --- Функции рисования вспомогательных элементов на экране ---
# Рисует индикатор осей: X и Y в 2D, Z в перспективе, в углу экрана.
def нарисовать_индикатор_осей(поверхность_pygame, углы_сцены_рад): 
    (у_x_сц, у_y_сц, у_z_сц) = углы_сцены_рад # Углы вращения основной 3D-сцены
    
    начало_x_экран = ОТСТУП_ИНД_ОСЕЙ_X; начало_y_экран = ВЫСОТА_ЭКРАНА - ОТСТУП_ИНД_ОСЕЙ_Y # Позиция индикатора
    шрифт = pygame.font.SysFont(None, 20, bold=True) # Шрифт для меток осей

    # Рисуем оси X и Y (2D, фиксированные на экране)
    pygame.draw.line(поверхность_pygame, ЦВЕТ_ИНД_ОСИ_X, (начало_x_экран, начало_y_экран), (начало_x_экран + ДЛИНА_ИНД_ОСЕЙ_2D, начало_y_экран), ТОЛЩИНА_ЛИНИИ_ИНД_ОСЕЙ)
    текст_x = шрифт.render('X', True, ЦВЕТ_ИНД_ОСИ_X); поверхность_pygame.blit(текст_x, (начало_x_экран + ДЛИНА_ИНД_ОСЕЙ_2D + 5, начало_y_экран - текст_x.get_height()//2))
    
    pygame.draw.line(поверхность_pygame, ЦВЕТ_ИНД_ОСИ_Y, (начало_x_экран, начало_y_экран), (начало_x_экран, начало_y_экран - ДЛИНА_ИНД_ОСЕЙ_2D), ТОЛЩИНА_ЛИНИИ_ИНД_ОСЕЙ)
    текст_y = шрифт.render('Y', True, ЦВЕТ_ИНД_ОСИ_Y); поверхность_pygame.blit(текст_y, (начало_x_экран - текст_y.get_width()//2, начало_y_экран - ДЛИНА_ИНД_ОСЕЙ_2D - 15))
    
    # Рисуем ось Z (3D, трансформируется и проецируется)
    z_ось_н_3d = np.array([0,0,-ДЛИНА_ИНД_ОСИ_Z_3D/2]); z_ось_к_3d = np.array([0,0,ДЛИНА_ИНД_ОСИ_Z_3D/2]) # 3D-координаты отрезка оси Z
    z_ось_н_п = повернуть_точку(z_ось_н_3d, у_x_сц,у_y_сц,у_z_сц); z_ось_к_п = повернуть_точку(z_ось_к_3d, у_x_сц,у_y_сц,у_z_сц) # Поворачиваем вместе со сценой
    # Проецируем на экран, используя начало координат индикатора как центр проекции
    sx_z_н,sy_z_н,_=спроецировать_точку(z_ось_н_п,МАСШТАБ_ДЛЯ_ПРОЕКЦИИ_Z_ИНД,начало_x_экран,начало_y_экран)
    sx_z_к,sy_z_к,_=спроецировать_точку(z_ось_к_п,МАСШТАБ_ДЛЯ_ПРОЕКЦИИ_Z_ИНД,начало_x_экран,начало_y_экран)
    pygame.draw.line(поверхность_pygame,ЦВЕТ_ИНД_ОСИ_Z,(sx_z_н,sy_z_н),(sx_z_к,sy_z_к),ТОЛЩИНА_ЛИНИИ_ИНД_ОСЕЙ)
    текст_z = шрифт.render('Z',True,ЦВЕТ_ИНД_ОСИ_Z); поверхность_pygame.blit(текст_z,(sx_z_к+5,sy_z_к-текст_z.get_height()//2))

# Рисует сетку на "полу" (плоскость Y=Y_ПЛОСКОСТИ_СЕТКИ).
def нарисовать_сетку_пола(поверхность_pygame, углы_рад, масштаб_сцены, центр_сцены_x, центр_сцены_y): # сократил имена аргументов для краткости
    (у_x,у_y,у_z)=углы_рад; макс_к=РАЗМЕР_СЕТКИ*ШАГ_СЕТКИ; линии=[]
    # Генерация 3D-координат для линий сетки
    for i in range(-РАЗМЕР_СЕТКИ,РАЗМЕР_СЕТКИ+1): x_к=i*ШАГ_СЕТКИ; линии.append((np.array([x_к,Y_ПЛОСКОСТИ_СЕТКИ,-макс_к]),np.array([x_к,Y_ПЛОСКОСТИ_СЕТКИ,макс_к]))) # Линии вдоль Z
    for i in range(-РАЗМЕР_СЕТКИ,РАЗМЕР_СЕТКИ+1): z_к=i*ШАГ_СЕТКИ; линии.append((np.array([-макс_к,Y_ПЛОСКОСТИ_СЕТКИ,z_к]),np.array([макс_к,Y_ПЛОСКОСТИ_СЕТКИ,z_к]))) # Линии вдоль X
    # Поворот, проекция и рисование каждой линии
    for p1_оригинал,p2_оригинал in линии: 
        p1_повернутая=повернуть_точку(p1_оригинал,у_x,у_y,у_z); p2_повернутая=повернуть_точку(p2_оригинал,у_x,у_y,у_z)
        sx1,sy1,_=спроецировать_точку(p1_повернутая,масштаб_сцены,центр_сцены_x,центр_сцены_y)
        sx2,sy2,_=спроецировать_точку(p2_повернутая,масштаб_сцены,центр_сцены_x,центр_сцены_y)
        pygame.draw.line(поверхность_pygame,ЦВЕТ_СЕТКИ,(sx1,sy1),(sx2,sy2),1) # Рисуем линию толщиной 1 пиксель

# --- Основная функция программы с интерактивным циклом Pygame ---
def main_interactive():
    global угол_пов_x_град,угол_пов_y_град,угол_пов_z_град,масштабный_коэфф,текущая_фигура,базовый_цвет_текущей_фигуры
    
    # Инициализация Pygame и его модулей
    pygame.init(); pygame.font.init()
    экран=pygame.display.set_mode((ШИРИНА_ЭКРАНА,ВЫСОТА_ЭКРАНА)); часы=pygame.time.Clock()
    
    # Первоначальная генерация геометрии выбранной фигуры
    вычислить_исходную_геометрию(текущая_фигура)
    
    работает=True; нужна_перерисовка=True # Флаги для управления циклом и перерисовкой
    
    # Параметры для плавного управления (скорости изменения)
    скорость_вращения_град_в_сек=45.0 
    скорость_масштабирования=1.25

    # --- Основной цикл программы ---
    while работает:
        dt=часы.get_time()/1000.0; dt=min(dt,0.1) # Время, прошедшее с прошлого кадра (delta time), с ограничением

        # --- Обработка событий (нажатия клавиш, мышь, закрытие окна) ---
        for событие in pygame.event.get(): 
            if событие.type==pygame.QUIT: работает=False # Закрытие окна
            if событие.type==pygame.KEYDOWN: # Обработка однократных нажатий клавиш
                if событие.key==pygame.K_ESCAPE: работает=False # Выход по ESCAPE
                if событие.key==pygame.K_TAB: # Смена фигуры по TAB
                    if текущая_фигура==ТИП_ФИГУРЫ_СПИРАЛЬ: 
                        тип_ф_новая=ТИП_ФИГУРЫ_УЗЕЛ; м_к_новый=80.0; у_x_новый=30.0; у_y_новый=0.0
                    else: 
                        тип_ф_новая=ТИП_ФИГУРЫ_СПИРАЛЬ; м_к_новый=50.0; у_x_новый=20.0; у_y_новый=30.0
                    # Обновление состояния для новой фигуры
                    текущая_фигура=тип_ф_новая;масштабный_коэфф=м_к_новый
                    угол_пов_x_град=у_x_новый;угол_пов_y_град=у_y_новый
                    вычислить_исходную_геометрию(тип_ф_новая); нужна_перерисовка=True
            if событие.type==pygame.MOUSEWHEEL: # Масштабирование колесиком мыши (дискретное)
                масштабный_коэфф_новый=масштабный_коэфф*(1.15 if событие.y>0 else 1/1.15)
                масштабный_коэфф=масштабный_коэфф_новый; нужна_перерисовка=True
        
        # --- Обработка зажатых клавиш для непрерывного (плавного) управления ---
        клавиши_нажаты=pygame.key.get_pressed(); изменилось_что_то_от_клавиш=False 
        # Вращение
        if клавиши_нажаты[pygame.K_LEFT]: угол_пов_x_град-=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_RIGHT]: угол_пов_x_град+=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_UP]: угол_пов_y_град+=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_DOWN]: угол_пов_y_град-=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_q]: угол_пов_z_град+=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_e]: угол_пов_z_град-=скорость_вращения_град_в_сек*dt; изменилось_что_то_от_клавиш=True
        # Масштабирование
        if клавиши_нажаты[pygame.K_PLUS]or клавиши_нажаты[pygame.K_EQUALS]: масштабный_коэфф*=(1+(скорость_масштабирования-1)*dt); изменилось_что_то_от_клавиш=True
        if клавиши_нажаты[pygame.K_MINUS]:
            if масштабный_коэфф>0.01: масштабный_коэфф/=(1+(скорость_масштабирования-1)*dt) # Защита от слишком малого масштаба
            изменилось_что_то_от_клавиш=True
        if изменилось_что_то_от_клавиш: нужна_перерисовка=True # Если были изменения от зажатых клавиш

        # --- Блок рендеринга (выполняется, если нужна_перерисовка == True) ---
        if нужна_перерисовка:
            # 1. Подготовка буферов: массив пикселей для основной фигуры и Z-буфер
            массив_пикселей_фигуры=np.full((ВЫСОТА_ЭКРАНА,ШИРИНА_ЭКРАНА,3),ЦВЕТ_ФОНА,dtype=np.uint8) 
            z_буфер=np.full((ВЫСОТА_ЭКРАНА,ШИРИНА_ЭКРАНА),np.inf,dtype=np.float32) # Инициализация бесконечностью (далеко)
            
            # Преобразование текущих углов поворота из градусов в радианы
            у_x_r,у_y_r,у_z_r=np.radians(угол_пов_x_град),np.radians(угол_пов_y_град),np.radians(угол_пов_z_град)
            углы_рад=(у_x_r,у_y_r,у_z_r) # Кортеж для удобной передачи в функции

            # 2. Рендеринг основной фигуры (квад за квадом, треугольник за треугольником)
            for i_u in range(текущие_шаги_u-1):
                for i_v in range(текущие_шаги_v-1):
                    # Получение вершин квада из предрасчитанной геометрии
                    п00,п10,п01,п11=(точки_поверхности_3d_оригинал[i_u,i_v],точки_поверхности_3d_оригинал[i_u+1,i_v],
                                     точки_поверхности_3d_оригинал[i_u,i_v+1],точки_поверхности_3d_оригинал[i_u+1,i_v+1])
                    # Получение и поворот нормали квада
                    нормаль_оригинал=нормали_квадов_оригинал[i_u,i_v]
                    нормаль_повернутая=повернуть_точку(нормаль_оригинал,*углы_рад)
                    # Расчет освещения (модель Ламберта + окружающий свет)
                    интенсивность_диффузного=max(0,np.dot(нормаль_повернутая,НАПРАВЛЕНИЕ_СВЕТА_МИР))
                    итоговая_яркость=min(1.0,ОКРУЖАЮЩИЙ_СВЕТ+ЯРКОСТЬ_ДИФФУЗНОГО*интенсивность_диффузного)
                    цвет_квада=tuple(max(0,min(255,int(c*итоговая_яркость))) for c in базовый_цвет_текущей_фигуры)
                    
                    # Отсечение невидимых граней (Back-face culling)
                    # Если Z-компонента повернутой нормали > 0 (в правой системе координат, где камера смотрит вдоль -Z),
                    # то грань обращена от камеры. Небольшой порог для стабильности.
                    if нормаль_повернутая[2]>0.001: continue 
                    
                    # Поворот и проекция вершин квада
                    спроецированные_вершины=[] 
                    for вершина_оригинал in [п00,п10,п11,п01]: # Порядок важен для треугольников
                        вершина_повернутая=повернуть_точку(вершина_оригинал,*углы_рад)
                        sx,sy,sz=спроецировать_точку(вершина_повернутая,масштабный_коэфф,ШИРИНА_ЭКРАНА/2,ВЫСОТА_ЭКРАНА/2)
                        спроецированные_вершины.append((sx,sy,sz))
                    v0,v1,v2,v3=спроецированные_вершины # Переименование для краткости
                    
                    # Растеризация квада как двух треугольников
                    нарисовать_треугольник(массив_пикселей_фигуры,z_буфер,v0,v1,v2,цвет_квада) # Треугольник 1
                    нарисовать_треугольник(массив_пикселей_фигуры,z_буфер,v0,v2,v3,цвет_квада) # Треугольник 2
            
            # 3. Создание финальной поверхности кадра (начинаем с чистого фона)
            финальная_поверхность_кадра=pygame.Surface((ШИРИНА_ЭКРАНА,ВЫСОТА_ЭКРАНА)) 
            финальная_поверхность_кадра.fill(ЦВЕТ_ФОНА)
            
            # 4. Рисуем сетку пола на эту финальную поверхность
            # Сетка будет под основной фигурой, так как фигура рисуется поверх с Z-тестом
            нарисовать_сетку_пола(финальная_поверхность_кадра,углы_рад,масштабный_коэфф,ШИРИНА_ЭКРАНА/2,ВЫСОТА_ЭКРАНА/2)
            
            # 5. "Накладываем" отрендеренную основную фигуру (из numpy массива) поверх сетки
            # Создаем pygame.Surface из numpy массива пикселей фигуры
            фигура_surface=pygame.surfarray.make_surface(np.transpose(массив_пикселей_фигуры,(1,0,2))) 
            # Устанавливаем цвет фона как "прозрачный" для этой поверхности фигуры
            фигура_surface.set_colorkey(ЦВЕТ_ФОНА) 
            # Копируем поверхность фигуры на финальную поверхность кадра (с учетом прозрачности)
            финальная_поверхность_кадра.blit(фигура_surface,(0,0))

            # 6. Рисуем индикатор осей поверх всего на финальной поверхности
            нарисовать_индикатор_осей(финальная_поверхность_кадра, углы_рад) 
            
            # 7. Отображаем финальную собранную поверхность на главном экране Pygame
            экран.blit(финальная_поверхность_кадра,(0,0))
            pygame.display.flip() # Обновляем весь экран
            
            нужна_перерисовка = False # Сбрасываем флаг после успешной перерисовки
            
            # Обновляем заголовок окна с FPS и текущими параметрами
            fps = часы.get_fps()
            pygame.display.set_caption(f"Фигура: {текущая_фигура.replace('_',' ').title()} | FPS: {fps:.1f} | Масштаб: {масштабный_коэфф:.1f}")
            # --- Конец блока рендеринга ---

        часы.tick(60) # Ограничение FPS 
    
    pygame.font.quit()
    pygame.quit()

if __name__ == "__main__":
    main_interactive()