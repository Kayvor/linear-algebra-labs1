## Отчет о работе: Программа для построения 3D графиков

### 1. Введение

Данный проект представляет собой программу на языке Python, предназначенную для интерактивной визуализации трехмерных параметрических функций. Основной задачей являлась разработка собственного механизма рендеринга "с нуля", без использования высокоуровневых 3D-библиотек и их готовых инструментов для отрисовки поверхностей. Программа реализует ключевые этапы графического конвейера, включая генерацию геометрии, 3D-трансформации, проекцию, расчет освещения и удаление невидимых поверхностей с помощью алгоритма Z-буфера. Для взаимодействия с пользователем и отображения 2D-графики используется библиотека Pygame.

### 2. Реализованные параметрические функции

В программе реализована возможность отображения двух различных параметрических поверхностей:

#### 2.1. Спиральная поверхность

Классическая спиральная форма, описываемая следующими параметрическими уравнениями:

*   `x = (α + β ⋅ cos(v)) ⋅ cos(u)`
*   `y = (α + β ⋅ cos(v)) ⋅ sin(u)`
*   `z = β ⋅ sin(v) + α ⋅ u`

Где:
*   `α` и `β` – константы, влияющие на радиус и "шаг" спирали. В программе используются значения: `α = 2.0`, `β = 0.5`.
*   `u` и `v` – параметры, изменяющиеся в диапазонах: `u ∈ [0, 4π]`, `v ∈ [0, 2π]`.
![image](https://github.com/user-attachments/assets/260e7f4f-d898-427a-ae81-0f30e479817d)

#### 2.2. Тороидальный узел (Torus Knot)

Более сложная, завязанная в узел трубчатая поверхность. Для ее генерации используется упрощенная параметризация, основанная на построении "трубки" вокруг центральной волнистой кривой:

1.  **Центральная кривая:**
    *   `x_center = R_major ⋅ cos(p ⋅ u)`
    *   `y_center = R_major ⋅ sin(p ⋅ u)`
    *   `z_waving = R_major ⋅ A_wave ⋅ sin(q ⋅ u)` (где `A_wave` - амплитуда волны, в коде 0.3)
2.  **Построение трубки:** В каждой точке центральной кривой вычисляется локальный ортонормированный базис (касательная `T`, нормаль `N1`, бинормаль `N2`). Точки на поверхности трубки генерируются по формуле:
    *   `P_surface(u,v) = P_center(u) + r_minor ⋅ (N1(u) ⋅ cos(v) + N2(u) ⋅ sin(v))`

Используемые параметры для узла типа (2,3) (трилистник):
*   `p = 2`, `q = 3`
*   `R_major = 2.0` (большой радиус "основы")
*   `r_minor = 0.5` (радиус "трубки")
*   Диапазоны параметров: `u ∈ [0, 2π]`, `v ∈ [0, 2π]`.
![image](https://github.com/user-attachments/assets/1e8af47b-48b8-4992-8ea0-65acff02e7a9)


### 3. Ключевые этапы программного рендерера

#### 3.1. Генерация геометрии (Меш)
Поверхность каждой функции аппроксимируется сеткой (мешем) из четырехугольников (квадов).
1.  **Дискретизация параметров:** Диапазоны изменения параметров `u` и `v` делятся на заданное количество шагов (`КОЛ_ВО_ШАГОВ_U`, `КОЛ_ВО_ШАГОВ_V`).
2.  **Расчет вершин:** Для каждой пары `(u_i, v_j)` вычисляются 3D-координаты `(x, y, z)` соответствующей точки на поверхности.
3.  **Расчет нормалей:** Для каждого квада, образованного четырьмя соседними вершинами, вычисляется вектор нормали к его поверхности. Нормаль определяется как нормализованное векторное произведение двух векторов, лежащих в плоскости квада (например, `(P_10 - P_00) × (P_01 - P_00)`). Нормали необходимы для корректного расчета освещения и отсечения невидимых граней.

#### 3.2. 3D Трансформации
К вершинам и нормалям применяются стандартные аффинные преобразования для изменения ориентации объекта в пространстве.
*   **Вращение:** Реализовано вращение вокруг осей X, Y и Z с использованием стандартных матриц поворота. Углы поворота (`угол_пов_x_град`, `угол_пов_y_град`, `угол_пов_z_град`) изменяются пользователем интерактивно.

#### 3.3. Проекция
Используется **ортографическая проекция** для преобразования 3D-координат в 2D-координаты экрана.
*   `screen_x = viewport_center_x + transformed_x ⋅ scale_factor`
*   `screen_y = viewport_center_y - transformed_y ⋅ scale_factor` (ось Y экрана направлена вниз)
    При этом координата `transformed_z` сохраняется как значение глубины для Z-буфера. `scale_factor` (`масштабный_коэфф`) управляет приближением/отдалением.

#### 3.4. Освещение
Применяется простая модель освещения, состоящая из двух компонентов:
*   **Окружающее освещение (Ambient):** Обеспечивает базовую видимость всех частей объекта, независимо от их ориентации: `I_ambient = Ambient_Intensity`.
*   **Диффузное освещение (Lambertian):** Интенсивность зависит от угла между нормалью к поверхности `N` и направлением на источник света `L`: `I_diffuse = Diffuse_Coefficient ⋅ max(0, dot(N, L))`.
Итоговая яркость: `Brightness = I_ambient + I_diffuse`. Цвет пикселя получается модуляцией базового цвета поверхности на эту яркость.

#### 3.5. Удаление невидимых поверхностей (Z-буфер)
Для корректного отображения глубины и перекрытия объектов используется Z-буфер.
1.  **Инициализация:** Создается 2D-массив (`z_буфер`) размером с экран, заполненный значениями максимальной глубины (`np.inf`).
2.  **Растеризация треугольников:** Каждый квад поверхности разбивается на два треугольника. Для каждого пикселя, покрываемого треугольником (определяется с помощью барицентрических координат):
    *   Интерполируется его глубина `depth_pixel`.
    *   Если `depth_pixel` меньше значения в `z_буфер` для этого пикселя, то пиксель окрашивается цветом треугольника, и `z_буфер` обновляется значением `depth_pixel`.

#### 3.6. Отсечение невидимых граней (Back-Face Culling)
Простая оптимизация, при которой полигоны, чья нормаль направлена от наблюдателя (в пространстве камеры), не обрабатываются и не рисуются. Это определяется знаком Z-компоненты повернутой нормали.

### 4. Интерактивность и вспомогательные элементы

*   **Управление:** Реализовано плавное вращение объекта вокруг осей X, Y, Z (стрелки, Q/E), плавное масштабирование (+/-) и дискретное масштабирование колесиком мыши. Скорость изменений зависит от времени между кадрами (`dt`) для независимости от FPS.
*   **Смена фигур:** Клавиша TAB позволяет переключаться между спиралью и тороидальным узлом.
*   **Сетка на "полу":** Вспомогательная сетка на плоскости Y=const, трансформирующаяся вместе со сценой, для улучшения восприятия перспективы.
*   **Индикатор осей:** В левом нижнем углу отображается:
    *   Оси X и Y как фиксированные 2D-линии (экранные "вправо" и "вверх").
    *   Ось Z как 3D-отрезок, вращающийся вместе со сценой и проецируемый из того же угла, показывая направление "вглубь/из" экрана.

### 5. Условия работы и ограничения

*   **Зависимости:** Python 3, Pygame, NumPy.
*   **Проекция:** Ортографическая.
*   **Освещение:** Упрощенное, без теней и сложных отражений.
*   **Производительность:** Зависит от детализации сетки (количества шагов U/V). Все расчеты производятся на CPU.

### 6. Заключение

Проект успешно демонстрирует создание собственного простого 3D-рендерера для параметрических функций. Реализованы ключевые этапы графического конвейера, обеспечена интерактивность и добавлены вспомогательные элементы для лучшего восприятия 3D-сцены.

Основной код программы находится в файле `main.py` (или как вы его назвали).
Ключевые функции:
*   `точка_спиральной_поверхности(...)`, `точка_тороидального_узла(...)`: Генерация точек фигур.
*   `повернуть_точку(...)` и ее компоненты: 3D-вращение.
*   `спроецировать_точку(...)`: Проекция.
*   `нарисовать_треугольник(...)`: Растеризация и Z-буфер.
*   `вычислить_исходную_геометрию(...)`: Подготовка данных модели.
*   `нарисовать_индикатор_осей(...)`, `нарисовать_сетку_пола(...)`: Вспомогательные элементы.
*   `main_interactive()`: Главный цикл программы, обработка событий и рендеринг.
